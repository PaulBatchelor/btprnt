#+TITLE: btprnt
A small library for drawing bitmap images.
* Files
btprnt writes itself to a single header file called
=btprnt.h=. Defining =BTPRNT_IMPL= will define the
functions, otherwise it is just function declarations.

#+NAME: btprnt.h
#+BEGIN_SRC c :tangle btprnt.h
#ifndef BTPRNT_H
#define BTPRNT_H
<<typedefs>>
<<errorcodes>>
<<btprnt_region_struct>>
<<funcdefs>>
#ifdef BTPRNT_IMPL
#include <math.h>
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif
<<structs>>
<<funcs>>
#endif
#endif
#+END_SRC
* The Top Level Interface
The =btprnt= interface is one that handles all the low-level
details.

#+NAME: typedefs
#+BEGIN_SRC c
typedef struct btprnt btprnt;
#+END_SRC

The btprnt struct contains a canvas, and a buffer.

#+NAME: structs
#+BEGIN_SRC c
struct btprnt {
    btprnt_buf *buf;
    btprnt_canvas *canvas;
};
#+END_SRC

Canvas can be retrieved using the function
=btprnt_canvas_get=.

#+NAME: funcdefs
#+BEGIN_SRC c
btprnt_canvas *btprnt_canvas_get(btprnt *b);
#+END_SRC
#+NAME: funcs
#+BEGIN_SRC c
btprnt_canvas *btprnt_canvas_get(btprnt *b)
{
    return b->canvas;
}
#+END_SRC

The buffer can be retrieved using =btprnt_buf_get=.

#+NAME: funcdefs
#+BEGIN_SRC c
btprnt_buf * btprnt_buf_get(btprnt *b);
#+END_SRC
#+NAME: funcs
#+BEGIN_SRC c
btprnt_buf * btprnt_buf_get(btprnt *b)
{
    return b->buf;
}
#+END_SRC

The function =btprnt_new= will allocate and return a new
btprnt instance. Internally, this will allocate and
initialize the canvas and the buffer. The dimensions of
the buffer are needed to be known at init time.

#+NAME: funcdefs
#+BEGIN_SRC c
btprnt * btprnt_new(int w, int h);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
btprnt * btprnt_new(int w, int h)
{
    btprnt *b;

    b = calloc(1, sizeof(btprnt));

    if (b == NULL) return NULL;

    b->buf = btprnt_buf_init(w, h);

    if (b->buf == NULL) {
        free(b);
        return NULL;
    }

    b->canvas = btprnt_canvas_new(b->buf);

    if (b->canvas == NULL) {
        btprnt_buf_free(&b->buf);
        free(b);
        return NULL;
    }
    return b;
}
#+END_SRC

The function =btprnt_del= will delete that which has
been previously allocated.

#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_del(btprnt **b);
#+END_SRC

This pointer notation is a bit too clever for my peabrain,
but it is very convenient. I will explain it while it is
still fresh in my head:

=b= is a pointer to a pointer to =btprnt= (aka double star)

=*b= will return the pointer to =btprnt=. We need this
to access things like =canvas= with =(*b)->canvas=.

The freeing functions take pointers to pointers (double
stars), so we need to give it the address of the pointer
=&(*b)->canvas=, NOT the pointer itself which would be
=(*b)->canvas=.

#+NAME: funcs
#+BEGIN_SRC c
void btprnt_del(btprnt **b)
{
    if (*b == NULL) return;
    btprnt_canvas_del(&(*b)->canvas);
    btprnt_buf_free(&(*b)->buf);
    free(*b);
    *b = NULL;
}
#+END_SRC

#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_del(btprnt **b);
#+END_SRC
* The Buffer
The lowest level data construct is a buffer. This is where
bits are written to.

#+NAME: typedefs
#+BEGIN_SRC c
typedef struct btprnt_buf btprnt_buf;
#+END_SRC

A bitmap has an array where it stores data, and integers
storing the width and a height.

#+NAME: structs
#+BEGIN_SRC c
struct btprnt_buf {
    int w;
    int h;
    int stride;
    unsigned char free;
    unsigned char *data;
};
#+END_SRC

The buffer is allocated + initialized with the function
=btprnt_buf_init=.

#+NAME: funcdefs
#+BEGIN_SRC c
btprnt_buf * btprnt_buf_init(int w, int h);
#+END_SRC

To make the math a bit easier, the rows will be rounded to
the nearest multiple of 8.

#+NAME: funcs
#+BEGIN_SRC c
btprnt_buf * btprnt_buf_init(int w, int h)
{
    btprnt_buf *b;
    int stride;

    b = calloc(1, sizeof(btprnt_buf));

    if (b == NULL) return NULL;

    b->free = 1;
    b->w = w;
    b->h = h;

    if (w % 8) {
        stride = ((w / 8) + 1) * 8;
    } else {
        stride = w / 8;
    }

    b->stride = stride;
    b->data = calloc(1, stride * h);

    if (b->data == NULL) {
        free(b);
        return NULL;
    }

    return b;
}
#+END_SRC

Buffers that use externally managed memory blocks can be
created with =btprnt_buf_extmem=

#+NAME: funcdefs
#+BEGIN_SRC c
btprnt_buf * btprnt_buf_extmem(int w, int h,
                               unsigned char *data);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
btprnt_buf * btprnt_buf_extmem(int w, int h,
                               unsigned char *data)
{
    btprnt_buf *b;
    int stride;

    b = calloc(1, sizeof(btprnt_buf));

    if (b == NULL) return NULL;

    b->free = 0;
    b->w = w;
    b->h = h;

    if (w % 8) {
        stride = ((w / 8) + 1) * 8;
    } else {
        stride = w / 8;
    }

    b->stride = stride;
    b->data = data;

    return b;
}
#+END_SRC

The buffer is freed with =btprnt_buf_free=.

#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_buf_free(btprnt_buf **buf);
#+END_SRC
The data and the struct must be freed. To prevent
double-free corruptions, the pointer is set to be NULL.
#+NAME: funcs
#+BEGIN_SRC c
void btprnt_buf_free(btprnt_buf **buf)
{
    if (*buf == NULL) return;
    if ((*buf)->free) free((*buf)->data);
    free(*buf);
    *buf = NULL;
}
#+END_SRC


The main operations are read + write with =btprnt_buf_read=
and =btprnt_buf_write=.

#+NAME: funcdefs
#+BEGIN_SRC c
unsigned char btprnt_buf_read(btprnt_buf *b, int x, int y);
void btprnt_buf_write(btprnt_buf *b, int x, int y, int c);
#+END_SRC
Reading bit is a matter of first finding the byte where it
is located, and then ANDing with the local bit location.

Multiplying the stride by the height gives us which to look
at. Adding x divided by 8 (bits to a byte), gives us the
byte offset.

No coordinate checks done here so be careful. This isn't
an interface to be accessed directly. Sanitized inputs are
expected to be here.

#+NAME: funcs
#+BEGIN_SRC c
unsigned char btprnt_buf_read(btprnt_buf *b, int x, int y)
{
    unsigned char bitpos;
    int pos;
    int off;

    off = x >> 3;
    pos = (y * b->stride) + off;
    bitpos = x - (off * 8);

    return (b->data[pos] & (1 << bitpos)) > 0;
}
#+END_SRC

Similar process with reading, except the buffer is toggled
on or off depending on the value of =c=.

#+NAME: funcs
#+BEGIN_SRC c
void btprnt_buf_write(btprnt_buf *b, int x, int y, int c)
{
    unsigned char bitpos;
    int pos;
    int off;

    off = x >> 3;
    pos = (y * b->stride) + off;
    bitpos = x - (off * 8);

    if (c) {
        b->data[pos] |= (1 << bitpos);
    } else {
        b->data[pos] &= ~(1 << bitpos);
    }
}
#+END_SRC

Dimensions for the buffer can be retrieved using
=btprnt_buf_width= and =btprnt_buf_height=.

#+NAME: funcdefs
#+BEGIN_SRC c
int btprnt_buf_width(btprnt_buf *buf);
int btprnt_buf_height(btprnt_buf *buf);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int btprnt_buf_width(btprnt_buf *buf)
{
    return buf->w;
}

int btprnt_buf_height(btprnt_buf *buf)
{
    return buf->h;
}
#+END_SRC

A buffer can be written to a pbm file with the function
=btprnt_buf_pbm=.

#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_buf_pbm(btprnt_buf *buf, const char *filename);
#+END_SRC
#+NAME: funcs
#+BEGIN_SRC c
void btprnt_buf_pbm(btprnt_buf *buf, const char *filename)
{
    FILE *fp;
    int x, y;
    int count;
    fp = fopen(filename, "w");

    if (buf == NULL || fp == NULL) return;

    fprintf(fp, "P1\n");
    fprintf(fp, "# Generated with btprnt\n");
    fprintf(fp, "%d %d\n", buf->w, buf->h);

    count = 0;
    for(y = 0; y < buf->h; y++) {
        for(x = 0; x < buf->w; x++) {
            fprintf(fp, "%d", btprnt_buf_read(buf, x, y));
            count++;
            if (count == 16) {
                count = 0;
                fprintf(fp, "\n");
            } else if (count != 0) {
                fprintf(fp, " ");
            }
        }
    }

    fclose(fp);
}
#+END_SRC

The buffer can also be written to an XBM file using
the function =btprnt_buf_xbm=.

#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_buf_xbm(btprnt_buf *buf,
                    const char *name,
                    const char *filename);
#+END_SRC
#+NAME: funcs
#+BEGIN_SRC c
void btprnt_buf_xbm(btprnt_buf *buf,
                    const char *name,
                    const char *filename)
{
    FILE *fp;
    int n;
    unsigned int count;

    fp = fopen(filename, "w");

    if (buf == NULL || fp == NULL) return;

    fprintf(fp, "#define %s_width %d\n", name, buf->w);
    fprintf(fp, "#define %s_height %d\n", name, buf->h);
    fprintf(fp, "static unsigned char %s_bits[] = {\n", name);

    count = buf->h * buf->stride;

    for (n = 0; n < count; n++) {
        fprintf(fp, "0x%x,", buf->data[n]);
        if ((n + 1) % 8 == 0) {
            fprintf(fp, "\n");
        } else {
            fprintf(fp, " ");
        }
    }

    fprintf(fp, "};");


    fclose(fp);
}
#+END_SRC
* The Region
** Region Overview
Regions are rectangular spaces to draw stuff into.

#+NAME: typedefs
#+BEGIN_SRC c
typedef struct btprnt_region btprnt_region;
#+END_SRC

A region provides two main things: a local coordinate
space, and rectangular clipping.

A region contains the top left coordinate position,
the region width, and the region height.

Because of how important regions for user level
operations, this struct is actually exposed in
the public header, allowing for instances to be allocated
on the stack instead of the heap.

#+NAME: btprnt_region_struct
#+BEGIN_SRC c
struct btprnt_region {
    btprnt_canvas *c;
    int w, h;
    int x, y;
};
#+END_SRC
** Create a New Region
A new region is created with =btprnt_region_new=.

#+NAME: funcdefs
#+BEGIN_SRC c
btprnt_region * btprnt_region_new(btprnt_canvas *c,
                                  int x, int y,
                                  int w, int h);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
btprnt_region * btprnt_region_new(btprnt_canvas *c,
                                  int x, int y,
                                  int w, int h)
{
    btprnt_region *r;

    r = calloc(1, sizeof(btprnt_region));

    if (r == NULL) return NULL;

    btprnt_region_init(c, r, x, y, w, h);

    return r;
}
#+END_SRC
** Freeing a region
It is freed with =btprnt_region_del=.

#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_region_del(btprnt_region **r);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void btprnt_region_del(btprnt_region **r)
{
    if (*r == NULL) return;
    free(*r);
    *r = NULL;
}
#+END_SRC
** Initializing a Region
If a region is to be allocated on the stack, it needs
only to be initialized. This can be done with
=btprnt_region_init=.

#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_region_init(btprnt_canvas *c,
                        btprnt_region *r,
                        int x, int y,
                        int w, int h);
#+END_SRC
#+NAME: funcs
#+BEGIN_SRC c
void btprnt_region_init(btprnt_canvas *c,
                        btprnt_region *r,
                        int x, int y,
                        int w, int h)
{
    btprnt_region_xpos_set(r, x);
    btprnt_region_ypos_set(r, y);
    btprnt_region_width_set(r, w);
    btprnt_region_height_set(r, h);
    r->c = c;
}
#+END_SRC
** Setters
The dimensions and position can be changed after it is
instantiated.

#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_region_xpos_set(btprnt_region *r, int x);
void btprnt_region_ypos_set(btprnt_region *r, int y);
void btprnt_region_width_set(btprnt_region *r, int w);
void btprnt_region_height_set(btprnt_region *r, int h);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void btprnt_region_xpos_set(btprnt_region *r, int x)
{
    r->x = x;
}

void btprnt_region_ypos_set(btprnt_region *r, int y)
{
    r->y = y;
}

void btprnt_region_width_set(btprnt_region *r, int w)
{
    r->w = w;
}

void btprnt_region_height_set(btprnt_region *r, int h)
{
    r->h = h;
}
#+END_SRC
** Writing a Pixel
Drawing utilities write to a region. The region ensures that
the pixel is not being written beyond the bounds of itself.
The actual placement on the buffer is handled via a canvas.

#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_region_draw(btprnt_region *r,
                        int x, int y,
                        int c);
#+END_SRC
For now, this function will be a little bit overpowered. In
the future, it might be better to break this up into
different components and flesh out the canvas interface.
#+NAME: funcs
#+BEGIN_SRC c
void btprnt_region_draw(btprnt_region *r,
                        int x, int y,
                        int c)
{
    btprnt_canvas *cv;
    int gx, gy;

    cv = r->c;

    if (x < 0 || x >= r->w) return;
    if (y < 0 || y >= r->h) return;

    gx = cv->offx + r->x + x;
    if (gx < 0 || gx >= cv->buf->w) return;
    gy = cv->offy + r->y + y;
    if (gy < 0 || gy >= cv->buf->h) return;

    btprnt_buf_write(cv->buf, gx, gy, c);
}
#+END_SRC
** Reading a Pixel
Get the pixel of the region with coordinates relative to
the region with =btprnt_region_read=.

#+NAME: funcdefs
#+BEGIN_SRC c
int btprnt_region_read(btprnt_region *r, int x, int y);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int btprnt_region_read(btprnt_region *r, int x, int y)
{
    btprnt_canvas *cv;
    int gx, gy;

    cv = r->c;

    if (x < 0 || x >= r->w) return 0;
    if (y < 0 || y >= r->h) return 0;

    gx = cv->offx + r->x + x;
    if (gx < 0 || gx >= cv->buf->w) return 0;
    gy = cv->offy + r->y + y;
    if (gy < 0 || gy >= cv->buf->h) return 0;

    return btprnt_buf_read(cv->buf, gx, gy);
}
#+END_SRC
* The Canvas
The canvas is an abstraction of the bitmap buffer. Regions
get drawn to the buffer via a canvas.

#+NAME: typedefs
#+BEGIN_SRC c
typedef struct btprnt_canvas btprnt_canvas;
#+END_SRC

It can be created with =btprnt_canvas_new=, and freed with
=btprnt_canvas_del=.

#+NAME: funcdefs
#+BEGIN_SRC c
btprnt_canvas * btprnt_canvas_new(btprnt_buf *buf);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
btprnt_canvas * btprnt_canvas_new(btprnt_buf *buf)
{
    btprnt_canvas *c;

    c = calloc(1, sizeof(btprnt_canvas));

    if (c == NULL) return NULL;

    c->buf = buf;
    btprnt_canvas_offx_set(c, 0);
    btprnt_canvas_offy_set(c, 0);
    return c;
}
#+END_SRC

#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_canvas_offx_set(btprnt_canvas *c, int x);
void btprnt_canvas_offy_set(btprnt_canvas *c, int y);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void btprnt_canvas_offx_set(btprnt_canvas *c, int x)
{
    c->offx = x;
}

void btprnt_canvas_offy_set(btprnt_canvas *c, int y)
{
    c->offy = y;
}
#+END_SRC

#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_canvas_del(btprnt_canvas **c);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void btprnt_canvas_del(btprnt_canvas **c)
{
    if (*c == NULL) return;
    free(*c);
    *c = NULL;
}
#+END_SRC

The main point of canvas abstraction is to provide an
infinite for regions to lie on. Any pixels out of range of
the buffer will be clipped by the canvas. Regions can be
resized and moved around without having to worry about
accessing bad memory.

#+NAME: structs
#+BEGIN_SRC c
struct btprnt_canvas {
    btprnt_buf *buf;
    int offx, offy;
};
#+END_SRC

The canvas has a global offset value. A canvas can be moved
around to make regions or less visible.
* Text
Text is next most important thing after all the
fundamentals. This can be broken up into levels.
** Level 1: Drawing tiles from a map
The lowest layer involves drawing a single tile
from a tile map stored in memory.

#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_draw_tile(btprnt_region *reg,
                      btprnt_buf *map,
                      int xpos, int ypos,
                      int mx, int my,
                      int w, int h,
                      int scale, int color);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void btprnt_draw_tile(btprnt_region *reg,
                      btprnt_buf *map,
                      int xpos, int ypos,
                      int mx, int my,
                      int w, int h,
                      int scale, int color)
{
    int startx;
    int starty;
    int x;
    int y;
    int c;

    startx = mx * w;
    starty = my * h;

    for (y = 0; y < h; y++) {
        for (x = 0; x < w; x++) {
            c = btprnt_buf_read(map,
                                startx + x,
                                starty + y);
            if (c) {
                if (scale == 1) {
                    btprnt_region_draw(reg,
                                       xpos + x, ypos + y,
                                       color);
                } else {
                    int sx, sy;
                    for (sy = 0; sy < scale; sy++) {
                        for (sx = 0; sx < scale; sx++) {
                            btprnt_region_draw(reg,
                                               xpos + x*scale + sx,
                                               ypos + y*scale + sy,
                                               color);
                        }
                    }
                }
            }
        }
    }
}
#+END_SRC
** Level 2: Drawing a character
To draw the right tile, we need to be be able to match
an ASCII character to the position on the map. Right now,
the layout for the map matches that of many of the C64
tileset dumps found online. More details on that later.

#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_draw_char(btprnt_region *reg,
                      btprnt_buf *map,
                      int xpos, int ypos,
                      int w, int h,
                      char c, int scale, int color);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void btprnt_draw_char(btprnt_region *reg,
                      btprnt_buf *map,
                      int xpos, int ypos,
                      int w, int h,
                      char c, int scale, int color)
{
    int gx, gy;
    char o;

    o = c - ' '; /* start at 0 */

    gx = o % (map->stride);
    gy = o / (map->stride);

    btprnt_draw_tile(reg, map,
                     xpos, ypos,
                     gx, gy,
                     w, h,
                     scale, color);
}
#+END_SRC
** Level 3: Drawing a string
From there, a string characters can be drawn onto a
region.

#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_draw_text(btprnt_region *reg,
                      btprnt_buf *map,
                      int xpos, int ypos,
                      int w, int h,
                      const char *str);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void btprnt_draw_text(btprnt_region *reg,
                      btprnt_buf *map,
                      int xpos, int ypos,
                      int w, int h,
                      const char *str)
{
    int len;
    int n;
    len = strlen(str);

    for (n = 0; n < len; n++) {
        btprnt_draw_char(reg, map,
                         xpos + w*n, ypos,
                         w, h,
                         str[n], 1, 1);
    }
}
#+END_SRC
** Level 4: Text wrapping
Since the dimensions of the textbox are known, some basic
text wrapping can be implemented.

#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_draw_wraptext(btprnt_region *reg,
                          btprnt_buf *map,
                          int xpos, int ypos,
                          int w, int h,
                          const char *str);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void btprnt_draw_wraptext(btprnt_region *reg,
                          btprnt_buf *map,
                          int xpos, int ypos,
                          int w, int h,
                          const char *str)
{
    int len;
    int n;
    int curpos;
    int line;
    int c;
    len = strlen(str);
    line = 0;
    curpos = 0;
    c = 0;

    for (n = 0; n < len; n++) {
        curpos = xpos + w*c;

        if (curpos >= reg->w) {
            curpos = xpos;
            line++;
            c = 0;
        }

        btprnt_draw_char(reg, map,
                         curpos, ypos + line*h,
                         w, h,
                         str[n], 1, 1);
        c++;
    }
}
#+END_SRC
** Level 5: Word Wrapping
With a bit more sophistication, some basic word wrapping can
done by writing the text chunks between spaces. If a word is
larger than what it left, it will know to go to the next
line. If the word is larger than how many characters there
are on a line, it will do the best it can to break to
wrap the text up.

#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_draw_textbox(btprnt_region *reg,
                         btprnt_buf *map,
                         int xpos, int ypos,
                         int w, int h,
                         const char *str,
                         int scale,
                         int color);
#+END_SRC

This function works by counting characters until it reaches
a space. Once it finds that space, it will write that chunk
of letters up to (and including) that space. Some arithmetic
will done. If it happens that the number of characters
exceeds the bounds of the current line position, it will
start a new line. (Space needs to be included with this
count so there aren't any trailing spaces at the end of a
line.) If it happens that the number of characters is
greater than the length of the line, it won't matter
if a newline happens, and the word will be split up as
best as it can.

To be clear: a newline *shouldn't* happen if the number
of characters in a word is longer than the width. A weird
edge case I ran into involved having the first word in
the textbox be long. The original code added a empty
line on the first line, which looked weird.

When the text has reached the end, it has to print out
the last word, if there is any. This process is pretty
much indentical to what happens in the for loop, except
that some of the variables updated don't matter.

For now, I literally copy-pasted this twice because I'm
tired and lazy. I may come back at some point and do
something more elegant when I have the time.

#+NAME: funcs
#+BEGIN_SRC c
void btprnt_draw_textbox(btprnt_region *reg,
                         btprnt_buf *map,
                         int xpos, int ypos,
                         int w, int h,
                         const char *str,
                         int scale,
                         int color)
{
    int len;
    int n;
    int start;
    int nchars;
    int c;
    int line;
    len = strlen(str);

    start = 0;
    nchars = 0;
    c = 0;
    line = 0;
    for (n = 0; n < len; n++) {
        nchars++;
        if (str[n] == ' ' || str[n] == '\n') {
            int wordlen;
            int off;
            int i;
            int curpos;
            char x;

            wordlen = nchars*w*scale;
            off = xpos + c*w*scale;

            if ((off + wordlen) > reg->w) {
                /* nested if is a clumsy, but it works */
                if (wordlen < reg->w) {
                    line++;
                    c = 0;
                }
            }

            for (i = 0; i < nchars; i++) {
                curpos = xpos + c*w*scale;

                x = str[start + i];

                if ((curpos + w*scale) > reg->w || x == '\n') {
                    curpos = xpos;
                    line++;
                    c = 0;
                }


                if (x != '\n') {
                    btprnt_draw_char(reg, map,
                                     curpos,
                                     ypos + line*h*scale,
                                     w, h, x, scale, color);
                    c++;
                }
            }

            start = n + 1;
            nchars = 0;
        }
    }

    if (nchars > 0) {
        /* duplicate code alert ring ring ring */
        int wordlen;
        int off;
        int i;
        int curpos;

        wordlen = nchars * w * scale;
        off = xpos + c*w*scale;

        if ((off + wordlen) > reg->w) {
            line++;
            c = 0;
        }

        for (i = 0; i < nchars; i++) {
            curpos = xpos + c*w*scale;

            if ((curpos + w*scale) > reg->w) {
                curpos = xpos;
                line++;
                c = 0;
            }

            btprnt_draw_char(reg, map,
                             curpos, ypos + line*h*scale,
                             w, h,
                             str[start + i], scale, color);
            c++;
        }

        start = n + 1;
        nchars = 0;
    }
}
#+END_SRC
* Fill
The function =btprnt_fill= will fill a region.
#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_fill(btprnt_region *reg, int clr);
#+END_SRC
#+NAME: funcs
#+BEGIN_SRC c
void btprnt_fill(btprnt_region *reg, int clr)
{
    int x, y;
    for (y = 0; y < reg->h; y++) {
        for (x = 0; x < reg->w; x++) {
            btprnt_region_draw(reg, x, y, clr);
        }
    }
}
#+END_SRC
* Lines
** Horizontal Line
A horizontal line can be drawn with =btprnt_draw_hline=.
#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_draw_hline(btprnt_region *r,
                       int x, int y,
                       int sz, int clr);
#+END_SRC
#+NAME: funcs
#+BEGIN_SRC c
void btprnt_draw_hline(btprnt_region *r,
                       int x, int y,
                       int sz, int clr)
{
    int n;

    for (n = 0; n < sz; n++) {
        btprnt_region_draw(r, x + n, y, clr);
    }
}
#+END_SRC
** Vertical Line
A horizontal line can be drawn with =btprnt_draw_vline=.
#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_draw_vline(btprnt_region *r,
                       int x, int y,
                       int sz, int clr);
#+END_SRC
#+NAME: funcs
#+BEGIN_SRC c
void btprnt_draw_vline(btprnt_region *r,
                       int x, int y,
                       int sz, int clr)
{
    int n;

    for (n = 0; n < sz; n++) {
        btprnt_region_draw(r, x, y + n, clr);
    }
}
#+END_SRC
** Regular Line
Bresenham line algorithm.

#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_draw_line(btprnt_region *reg,
                      int x0, int y0,
                      int x1, int y1,
                      int clr);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static void swap(int *a, int *b)
{
    int tmp;
    tmp = *a;
    *a = *b;
    *b = tmp;
}

void btprnt_draw_line(btprnt_region *reg,
                      int x0, int y0,
                      int x1, int y1,
                      int clr)
{
    int x, y;
    int dx, dy;
    int derror2;
    int error2;
    char steep = 0;

    if (abs(x0 - x1) < abs(y0 - y1)) {
        swap(&x0, &y0);
        swap(&x1, &y1);
        steep = 1;
    }

    if (x0 > x1) {
        swap(&x0, &x1);
        swap(&y0, &y1);
    }

    dx = x1 - x0;
    dy = y1 - y0;
    derror2 = abs(dy) * 2;
    error2 = 0;
    y = y0;

    for (x = x0; x < x1; x++) {
        if (steep) {
            btprnt_region_draw(reg, y, x, clr);
        } else {
            btprnt_region_draw(reg, x, y, clr);
        }
        error2 += derror2;
        if (error2 > dx) {
            y += (y1 > y0 ? 1 : -1);
            error2 -= dx * 2;
        }
    }
}
#+END_SRC
** Thick Line
=btprnt_draw_thickline= draws a thick line. This is a
modification of the Bresenham algorithm. Instead of pixels,
little circles are drawn.

#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_draw_thickline(btprnt_region *reg,
                           int x0, int y0,
                           int x1, int y1,
                           int thick,
                           int clr);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void btprnt_draw_thickline(btprnt_region *reg,
                           int x0, int y0,
                           int x1, int y1,
                           int thick,
                           int clr)
{
    int x, y;
    int dx, dy;
    int derror2;
    int error2;
    char steep = 0;

    if (abs(x0 - x1) < abs(y0 - y1)) {
        swap(&x0, &y0);
        swap(&x1, &y1);
        steep = 1;
    }

    if (x0 > x1) {
        swap(&x0, &x1);
        swap(&y0, &y1);
    }

    dx = x1 - x0;
    dy = y1 - y0;
    derror2 = abs(dy) * 2;
    error2 = 0;
    y = y0;

    for (x = x0; x < x1; x++) {
        if (steep) {
            btprnt_draw_circ_filled(reg, y, x, thick, clr);
        } else {
            btprnt_draw_circ_filled(reg, x, y, thick, clr);
        }
        error2 += derror2;
        if (error2 > dx) {
            y += (y1 > y0 ? 1 : -1);
            error2 -= dx * 2;
        }
    }
}
#+END_SRC

** Slope Line
Draws N pixel steps with a specified slope, and returns
the last coordinate (if the values are not NULL).

This is created with the intention of facilitating
generative pixel art.

#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_draw_slopeline(btprnt_region *r,
                           int xstart,
                           int ystart,
                           int xslp,
                           int yslp,
                           int nsteps,
                           int clr,
                           int *xlast,
                           int *ylast);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void btprnt_draw_slopeline(btprnt_region *r,
                           int xstart,
                           int ystart,
                           int xslp,
                           int yslp,
                           int nsteps,
                           int clr,
                           int *xlast,
                           int *ylast)
{
    int c;
    int xp, yp;
    int ydir, xdir;

    c = nsteps;

    xp = xstart;
    yp = ystart;

    xdir = (xslp < 0) ? -1 : 1;
    ydir = (yslp < 0) ? -1 : 1;

    xslp = abs(xslp);
    yslp = abs(yslp);

    while (c > 0) {
        int x, y;
        for (x = 0; x < xslp; x++) {
            btprnt_region_draw(r, xp, yp, clr);
            c--;
            if (c <= 0) break;
            xp += xdir;
        }

        if (c <= 0) break;

        for (y = 0; y < yslp; y++) {
            if (y > 0) {
                btprnt_region_draw(r, xp - xdir, yp, clr);
                c--;
                if (c <= 0) break;
            }
            yp += ydir;
        }

    }

    if (xlast != NULL) *xlast = xp;
    if (ylast != NULL) *ylast = yp;
}
#+END_SRC
** TODO Pattern Line
Draws a horizontal using a pattern for color.
This will be the base for pattern-filled
shapes.
* Rectangle
** Stroked Rectangle
#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_draw_rect(btprnt_region *r,
                      int x, int y,
                      int w, int h,
                      int clr);
#+END_SRC
#+NAME: funcs
#+BEGIN_SRC c
void btprnt_draw_rect(btprnt_region *r,
                      int x, int y,
                      int w, int h,
                      int clr)
{
    btprnt_draw_hline(r, x, y, w, clr);
    btprnt_draw_hline(r, x, y + (h - 1), w, clr);
    btprnt_draw_vline(r, x, y, h, clr);
    btprnt_draw_vline(r, x + (w - 1), y, h, clr);
}
#+END_SRC
** Filled Rectangle
#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_draw_rect_filled(btprnt_region *r,
                             int xpos, int ypos,
                             int w, int h,
                             int clr);
#+END_SRC
#+NAME: funcs
#+BEGIN_SRC c
void btprnt_draw_rect_filled(btprnt_region *r,
                             int xpos, int ypos,
                             int w, int h,
                             int clr)
{
    int x, y;

    for (y = 0; y < h; y++) {
        for (x = 0; x < w; x++) {
            btprnt_region_draw(r,
                               xpos + x,
                               ypos + y,
                               clr);
        }
    }
}
#+END_SRC
* Circle
** Stroked Circle
Midpoint circle algorithm.

I don't know where I found the code for the first algorithm,
but it was too pointy at the compass coordinates. This one
is slightly more expensive, but makes for a much smoother
circle:
[[https://iq.opengenus.org/bresenhams-circle-drawing-algorithm/]]

That ones a bit boxy, so I tried this one:
[[https://zcsaha.github.io/computer-graphics/midpoint-circle-drawing-algorithm-in-c.html]]

I'm not great either. Kind of looks like a polygon when the
radius is 16. We're keeping it at that for now.
#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_draw_circ(btprnt_region *r,
                      int cx, int cy,
                      int rad,
                      int clr);
#+END_SRC
#+NAME: funcs
#+BEGIN_SRC c
static void circ_pixel(btprnt_region *r,
                       int cx, int cy,
                       int x, int y,
                       int clr)
{
    btprnt_region_draw(r, cx - x, cy + y, clr);
    btprnt_region_draw(r, cx + x, cy + y, clr);
    btprnt_region_draw(r, cx - y, cy + x, clr);
    btprnt_region_draw(r, cx + y, cy + x, clr);
    btprnt_region_draw(r, cx + x, cy - y, clr);
    btprnt_region_draw(r, cx - x, cy - y, clr);
    btprnt_region_draw(r, cx + y, cy - x, clr);
    btprnt_region_draw(r, cx - y, cy - x, clr);
}

void btprnt_draw_circ(btprnt_region *r,
                      int cx, int cy,
                      int rad,
                      int clr)
{
    int x;
    int y;
    int err;

    x = 0;
    y = rad;
    err = 1 - rad;

    circ_pixel(r, cx, cy, x, y, clr);

    while (x < y) {
        x++;

        if (err < 0) {
            err += 2 * x + 1;
        } else {
            y--;
            err += 2 * (x - y) + 1;
        }

        circ_pixel(r, cx, cy, x, y, clr);
    }
}
#+END_SRC
** Filled Circle
=btprnt_draw_circ_filled= uses an adaptation of the midpoint
circle algorithm to draw a filled circle. It has been
adapated from =btprnt_draw_circ=.

#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_draw_circ_filled(btprnt_region *r,
                      int cx, int cy,
                      int rad,
                      int clr);
#+END_SRC


#+NAME: funcs
#+BEGIN_SRC c
static void circ_line(btprnt_region *r,
                       int cx, int cy,
                       int x, int y,
                       int clr)
{
    btprnt_draw_line(r,
                     cx - x, cy + y,
                     cx + x, cy + y,
                     clr);
    btprnt_draw_line(r,
                     cx - y, cy + x,
                     cx + y, cy + x,
                     clr);
    btprnt_draw_line(r,
                     cx + x, cy - y,
                     cx - x, cy - y,
                     clr);
    btprnt_draw_line(r,
                     cx + y, cy - x,
                     cx - y, cy - x,
                     clr);

}

void btprnt_draw_circ_filled(btprnt_region *r,
                      int cx, int cy,
                      int rad,
                      int clr)
{
    int x;
    int y;
    int err;

    x = 0;
    y = rad;
    err = 1 - rad;

    circ_line(r, cx, cy, x, y, clr);

    while (x < y) {
        x++;

        if (err < 0) {
            err += 2 * x + 1;
        } else {
            y--;
            err += 2 * (x - y) + 1;
        }

        circ_line(r, cx, cy, x, y, clr);
    }
}
#+END_SRC
** Thick Circle
=btprnt_draw_thickcirc= will draw a circle
with a thick outline with a radius =rad=, thickness
=thick=, and color =c=.
This works like the normal midpoint circle algorithm,
except that it draws filled circles instead of pixels.

#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_draw_thickcirc(btprnt_region *r,
                           int cx, int cy,
                           int rad, int thick,
                           int clr);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static void circ_dots(btprnt_region *r,
                       int cx, int cy,
                       int x, int y,
                       int clr, int thick)
{
    btprnt_draw_circ_filled(r, cx - x, cy + y, thick, clr);
    btprnt_draw_circ_filled(r, cx + x, cy + y, thick, clr);
    btprnt_draw_circ_filled(r, cx - y, cy + x, thick, clr);
    btprnt_draw_circ_filled(r, cx + y, cy + x, thick, clr);
    btprnt_draw_circ_filled(r, cx + x, cy - y, thick, clr);
    btprnt_draw_circ_filled(r, cx - x, cy - y, thick, clr);
    btprnt_draw_circ_filled(r, cx + y, cy - x, thick, clr);
    btprnt_draw_circ_filled(r, cx - y, cy - x, thick, clr);
}

void btprnt_draw_thickcirc(btprnt_region *r,
                           int cx, int cy,
                           int rad, int thick,
                           int clr)
{
    int x;
    int y;
    int err;

    x = 0;
    y = rad;
    err = 1 - rad;

    circ_dots(r, cx, cy, x, y, clr, thick);

    while (x < y) {
        x++;

        if (err < 0) {
            err += 2 * x + 1;
        } else {
            y--;
            err += 2 * (x - y) + 1;
        }

        circ_dots(r, cx, cy, x, y, clr, thick);
    }
}
#+END_SRC
* TODO Rounded Rectangle
** Stroked Rounded Rectangle
** Filled Rounded Rectangle
* Triangle
A filled triangle is ideal for arrows in flowcharts!

The algorithm for this particular rasterization method
is based off the one found [[ http://www.sunshine2k.de/coding/java/TriangleRasterization/TriangleRasterization.html][here]].

The paramters supplied are the 3 vertices of the triangle.

Note: I'm using 1-indexed variables here to better match
the variables in the algorithm.

#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_draw_triangle(btprnt_region *r,
                          int v1x, int v1y,
                          int v2x, int v2y,
                          int v3x, int v3y,
                          int c);
#+END_SRC

Before the processing begins, vertices are sorted out
in ascending order by y, making v1 the highest point.

#+NAME: sort_vertices_by_y
#+BEGIN_SRC c
{
    int tmpx;
    int tmpy;

    if (v1y > v2y) {
        tmpy = v1y;
        tmpx = v1x;

        v1y = v2y;
        v1x = v2x;

        v2y = tmpy;
        v2x = tmpx;
    }

    if (v1y > v3y) {
        tmpy = v1y;
        tmpx = v1x;

        v1y = v3y;
        v1x = v3x;

        v3y = tmpy;
        v3x = tmpx;
    }

    if (v2y > v3y) {
        tmpy = v2y;
        tmpx = v2x;

        v2y = v3y;
        v2x = v3x;

        v3y = tmpy;
        v3x = tmpx;
    }
}
#+END_SRC

The bresenham approach to filling involves draw two lines in
parallel, and then drawing the horizontal lines between them.

This particular adaptation is from the java code, and
assumes that vertices 2 + 3 sahre the same Y axis.

#+NAME: flat_triangle_fill
#+BEGIN_SRC c
static int signum(int x)
{
    if (x < 0) return -1;
    if (x > 0) return 1;
    else return 0;
}


static void bresenham_fill(btprnt_region *r,
                           int v1x, int v1y,
                           int v2x, int v2y,
                           int v3x, int v3y,
                           int c)
{
    int vtmp1x;
    int vtmp1y;
    int vtmp2x;
    int vtmp2y;

    int changed1;
    int changed2;

    int dx1;
    int dy1;
    int dx2;
    int dy2;

    int signx1;
    int signx2;

    int signy1;
    int signy2;

    int e1;
    int e2;

    int i;

    vtmp1x = v1x;
    vtmp1y = v1y;

    vtmp2x = v1x;
    vtmp2y = v1y;

    changed1 = 0;
    changed2 = 0;

    dx1 = abs(v2x - v1x);
    dy1 = abs(v2y - v1y);

    dx2 = abs(v3x - v1x);
    dy2 = abs(v3y - v1y);

    signx1 = signum(v2x - v1x);
    signx2 = signum(v3x - v1x);

    signy1 = signum(v2y - v1y);
    signy2 = signum(v3y - v1y);

    if (dy1 > dx1) {
        int tmp;
        tmp = dx1;
        dx1 = dy1;
        dy1 = tmp;
        changed1 = 1;
    }

    if (dy2 > dx2) {
        int tmp;
        tmp = dx2;
        dx2 = dy2;
        dy2 = tmp;
        changed2 = 1;
    }

    e1 = 2 * dy1 - dx1;
    e2 = 2 * dy2 - dx2;

    for(i = 0; i <= dx1; i++) {
        btprnt_draw_line(r, vtmp1x, vtmp1y, vtmp2x, vtmp2y, c);

        while (e1 >= 0) {
            if (changed1) vtmp1x += signx1;
            else vtmp1y += signy1;

            e1 = e1 - 2 * dx1;
        }

        if (changed1) vtmp1y += signy1;
        else vtmp1x += signx1;

        e1 = e1 + 2 * dy1;

        while (vtmp2y != vtmp1y) {
            while (e2 >= 0) {
                if (changed2) vtmp2x += signx2;
                else vtmp2y += signy2;

                e2 = e2 - 2 * dx2;
            }

            if (changed2) vtmp2y += signy2;
            else vtmp2x += signx2;

            e2 = e2 + 2 * dy2;
        }
    }

}
#+END_SRC

In the more general case, the triangle is split in half into
two smaller triangles: one with a flat bottom, the other
with a flat top.

#+NAME: split_the_triangle
#+BEGIN_SRC c
int v4x, v4y;

v4x = (v1x +
    ((float)(v2y - v1y)/(v3y - v1y)) *
    (v3x - v1x));
v4y = v2y;

bresenham_fill(r,
               v1x, v1y,
               v2x, v2y,
               v4x, v4y,
               c);

bresenham_fill(r,
               v3x, v3y,
               v2x, v2y,
               v4x, v4y,
               c);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
<<flat_triangle_fill>>

void btprnt_draw_triangle(btprnt_region *r,
                          int v1x, int v1y,
                          int v2x, int v2y,
                          int v3x, int v3y,
                          int c)
{
    <<sort_vertices_by_y>>
    if (v2y == v3y) {
        bresenham_fill(r,
                       v1x, v1y,
                       v2x, v2y,
                       v3x, v3y,
                       c);
    } if (v1y == v2y) {
        bresenham_fill(r,
                       v3x, v3y,
                       v1x, v1y,
                       v2x, v2y,
                       c);
    } else {
        <<split_the_triangle>>
    }

}
#+END_SRC
* Arrow
This draws an arrowed line. One can specify if the start and
end points have an arrow.

#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_draw_arrow(btprnt_region *r,
                       int start_x, int start_y,
                       int end_x, int end_y,
                       int arrow_start,
                       int arrow_end,
                       int draw_line,
                       int c);
#+END_SRC

Arrowheads are equalateral triangles, angled relative to the
slope of the line.

#+NAME: funcs
#+BEGIN_SRC c
void btprnt_draw_arrow(btprnt_region *r,
                       int start_x, int start_y,
                       int end_x, int end_y,
                       int arrow_start,
                       int arrow_end,
                       int draw_line,
                       int c)
{
    int sz;
    float angle;
    float off;
    int ptx[2];
    int pty[2];
    int dx;
    int dy;
    int dir;

    if (start_x > end_x) {
        dir = -1;
    } else {
        dir = 1;
    }

    sz = 9;

    dx = end_x - start_x;
    dy = end_y - start_y;

    off = asin(dx / sqrt(dx*dx + dy*dy));

    if (off < 0) {
        dir *= -1;
    }

    angle = 30;
    /* convert to radians */
    angle *= M_PI / 180.0;

    if (draw_line) {
        btprnt_draw_line(r,
                        start_x, start_y,
                        end_x, end_y, c);
    }

    if (arrow_start) {
        ptx[0] = start_x + dir * sz * sin(angle + off);
        pty[0] = start_y + dir * sz * cos(angle + off);

        ptx[1] = start_x + dir * sz * sin(off - angle);
        pty[1] = start_y + dir * sz * cos(off - angle);

        btprnt_draw_triangle(r,
                            start_x, start_y,
                            ptx[0], pty[0],
                            ptx[1], pty[1],
                            c);
    }

    if (arrow_end) {
        ptx[0] = end_x + -dir * sz * sin(angle + off);
        pty[0] = end_y + -dir * sz * cos(angle + off);

        ptx[1] = end_x + -dir * sz * sin(off - angle);
        pty[1] = end_y + -dir * sz * cos(off - angle);

        btprnt_draw_triangle(r,
                            end_x, end_y,
                            ptx[0], pty[0],
                            ptx[1], pty[1],
                            c);

    }
}
#+END_SRC
* Bezier Curve
Adapted from the bresenham bezier found at
[[http://members.chello.at/~easyfilter/bresenham.html][this page]], as
well as this [[https://stackoverflow.com/questions/31757501/pixel-by-pixel-b%C3%A9zier-curve][stackoverflow post]]

#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_draw_bezier(btprnt_region *reg,
                        int x0, int y0,
                        int x1, int y1,
                        int x2, int y2,
                        int c);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
<<draw_bezier_seg>>
void btprnt_draw_bezier(btprnt_region *reg,
                        int x0, int y0,
                        int x1, int y1,
                        int x2, int y2,
                        int c)
{
    int x, y;
    double t, r;

    x = x0-x1;
    y = y0-y1;
    t = x0-2*x1+x2;

    if ((long)x*(x2-x1) > 0) {
        if ((long)y*(y2-y1) > 0)
            if (fabs((y0-2*y1+y2)/t*x) > abs(y)) {
                x0 = x2; x2 = x+x1; y0 = y2; y2 = y+y1;
            }
        t = (x0-x1)/t;
        r = (1-t)*((1-t)*y0+2.0*t*y1)+t*t*y2;
        t = (x0*x2-x1*x1)*t/(x0-x1);
        x = floor(t+0.5); y = floor(r+0.5);
        r = (y1-y0)*(t-x0)/(x1-x0)+y0;
        bezierseg(reg, x0, y0, x, floor(r+0.5), x, y, c);
        r = (y1-y2)*(t-x2)/(x1-x2)+y2;
        x0 = x1 = x; y0 = y; y1 = floor(r+0.5);
    }

    if ((long)(y0-y1)*(y2-y1) > 0) {
        t = y0-2*y1+y2; t = (y0-y1)/t;
        r = (1-t)*((1-t)*x0+2.0*t*x1)+t*t*x2;
        t = (y0*y2-y1*y1)*t/(y0-y1);
        x = floor(r+0.5); y = floor(t+0.5);
        r = (x1-x0)*(t-y0)/(y1-y0)+x0;
        bezierseg(reg, x0, y0, floor(r+0.5), y, x, y, c);
        r = (x1-x2)*(t-y2)/(y1-y2)+x2;
        x0 = x; x1 = floor(r+0.5); y0 = y1 = y;
    }

    bezierseg(reg, x0, y0, x1, y1, x2, y2, c);
}
#+END_SRC

#+NAME: draw_bezier_seg
#+BEGIN_SRC c
static void bezierseg(btprnt_region *r,
                      int x0, int y0,
                      int x1, int y1,
                      int x2, int y2,
                      int c)
{
    int sx, sy;
    long xx, yy, xy;
    double dx, dy, err, cur;
    int rc;

    sx = x2-x1;
    sy = y2-y1;
    xx = x0-x1;
    yy = y0-y1;

    cur = xx*sy-yy*sx;

    rc = xx*sx <= 0 && yy*sy <= 0;

    if (!rc) return;

    if (sx*(long)sx+sy*(long)sy > xx*xx+yy*yy) {
        x2 = x0;
        x0 = sx+x1;
        y2 = y0;
        y0 = sy+y1;
        cur = -cur;
    }

    if (cur != 0) {
        xx += sx;
        xx *= sx = x0 < x2 ? 1 : -1;

        yy += sy;
        yy *= sy = y0 < y2 ? 1 : -1;

        xy = 2*xx*yy;
        xx *= xx;
        yy *= yy;

        if (cur*sx*sy < 0) {
            xx = -xx;
            yy = -yy;
            xy = -xy;
            cur = -cur;
        }

        dx = 4.0*sy*cur*(x1-x0)+xx-xy;
        dy = 4.0*sx*cur*(y0-y1)+yy-xy;

        xx += xx;
        yy += yy;
        err = dx+dy+xy;

        do {
            btprnt_region_draw(r, x0, y0, c);

            if (x0 == x2 && y0 == y2) return;

            y1 = 2*err < dx;

            if (2*err > dy) {
                x0 += sx;
                dx -= xy;
                err += dy += yy;
            }

            if (y1) {
                y0 += sy;
                dy -= xy;
                err += dx += xx;
            }
        } while (dy < dx );
    }

    btprnt_draw_line(r, x0, y0, x2, y2, c);
}
#+END_SRC
* Bezier Arrow
Like an arrow, but with a bezier curved line.

#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_draw_bezier_arrow(btprnt_region *r,
                              int start_x, int start_y,
                              int end_x, int end_y,
                              int ctrl_x, int ctrl_y,
                              int arrow_start,
                              int arrow_end,
                              int c);
#+END_SRC

Internally, this is done by drawing two arrowheads pointing
away from a control point, then drawing a bezier curve
connecting those two points.

#+NAME: funcs
#+BEGIN_SRC c
void btprnt_draw_bezier_arrow(btprnt_region *r,
                              int start_x, int start_y,
                              int end_x, int end_y,
                              int ctrl_x, int ctrl_y,
                              int arrow_start,
                              int arrow_end,
                              int c)
{
    btprnt_draw_arrow(r,
                      start_x, start_y,
                      ctrl_x, ctrl_y,
                      1, 0, 0, c);

    btprnt_draw_arrow(r,
                      end_x, end_y,
                      ctrl_x, ctrl_y,
                      1, 0, 0, c);

    btprnt_draw_bezier(r,
                       start_x, start_y,
                       ctrl_x, ctrl_y,
                       end_x, end_y,
                       c);
}
#+END_SRC
* Tiny Tile
A tiny tile is a 8x8 tile that can be specified in
only 3 bytes. It does this breaking up the tile into
4-bit 2x2 blocks, and then restricting those blocks
to be only 2 patterns. The first byte stores what
those two patterns are, and then the 2 remaining
bytes store the indexes.

#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_draw_tinytile(btprnt_region *r,
                          int xpos,
                          int ypos,
                          int b0,
                          int b1,
                          int b2);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void btprnt_draw_tinytile(btprnt_region *r,
                          int xpos,
                          int ypos,
                          int b0,
                          int b1,
                          int b2)
{
    int x, y;
    b0 &= 0xff;
    b1 &= 0xff;
    b2 &= 0xff;

    for (y = 0; y < 4; y++) {
        for (x = 0; x < 4; x++) {
            unsigned char pat;
            int xoff, yoff;

            if (y < 2) {
                pat = (b1 >> (4 * y)) & (1 << x);
            } else {
                pat = (b2 >> (4 * (y - 2))) & (1 << x);
            }

            pat = (pat ? (b0>>4) : b0) & 0xf;

            xoff = (x<<1) + xpos;
            yoff = (y<<1) + ypos;

            btprnt_region_draw(r,
                               xoff, yoff,
                               pat & 1);
            btprnt_region_draw(r,
                               xoff + 1, yoff,
                               (pat & 2) >> 1);
            btprnt_region_draw(r,
                               xoff, yoff + 1,
                               (pat & 4) >> 2);
            btprnt_region_draw(r,
                               xoff + 1, yoff + 1,
                               (pat & 8) >> 3);
        }
    }
}
#+END_SRC
* Error Codes
Right now, =BTPRNT_OK= and =BTPRNT_NOT_OK= are all that
is needed.

#+NAME: errorcodes
#+BEGIN_SRC c
enum {
    BTPRNT_OK,
    BTPRNT_NOT_OK
};
#+END_SRC
* Layout
This section outlines a set of tools used to help assist
building layouts. Layouts are created by making a region
that is subregion of another region.

The operations below are designed to take in a one region
and output a region. Both regions need to be pre-allocated
ahead of time. If something goes wrong, these operations
will return an error code of some kind.
** outline
The function =btprnt_layout_outline= draws box outside
of the region. This can be used for debugging and
visualization.

#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_layout_outline(btprnt_region *r, int c);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void btprnt_layout_outline(btprnt_region *r, int c)
{
    btprnt_region o;
    o = *r;
    o.x--;
    o.y--;
    o.w += 2;
    o.h += 2;
    btprnt_draw_rect(&o, 0, 0, o.w, o.h, c);
}
#+END_SRC
** Centerbox
The function =btprnt_layout_centerbox= configures a
subregion of a particular width and height that is centered
in the middle of another region. If the width or height are
out of bounds, an error is returned.

#+NAME: funcdefs
#+BEGIN_SRC c
int btprnt_layout_centerbox(btprnt_region *r,
                            int w, int h,
                            btprnt_region *s);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int btprnt_layout_centerbox(btprnt_region *r,
                            int w, int h,
                            btprnt_region *s)
{
    int vmargin;
    int hmargin;

    hmargin = (r->w - w) / 2;
    vmargin = (r->h - h) / 2;


    if (hmargin < 0 || vmargin < 0) {
        s->c = r->c;
        s->x = 0;
        s->y = 0;
        s->w = 0;
        s->h = 0;
        return BTPRNT_NOT_OK;
    }

    s->c = r->c;
    s->x = r->x + hmargin;
    s->y = r->y + vmargin;
    s->w = w;
    s->h = h;

    return BTPRNT_OK;
}
#+END_SRC
** Border
The function =btprnt_layout_border= configures a subregions
with equal-sized margins surrounding it.

#+NAME: funcdefs
#+BEGIN_SRC c
int btprnt_layout_border(btprnt_region *r,
                         int border,
                         btprnt_region *s);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int btprnt_layout_border(btprnt_region *r,
                         int border,
                         btprnt_region *s)
{
    if (r->w < (2 * border) || r->h < (2 * border)) {
        return BTPRNT_NOT_OK;
    }

    s->c = r->c;
    s->x = r->x + border;
    s->y = r->y + border;
    s->w = r->w - 2*border;
    s->h = r->h - 2*border;

    return BTPRNT_OK;
}
#+END_SRC
** Grid
The function =btprnt_layout_grid= returns a region that
belongs to a grid of arbitrary rows and columns.

#+NAME: funcdefs
#+BEGIN_SRC c
int btprnt_layout_grid(btprnt_region *r,
                       int nrows,
                       int ncols,
                       int row,
                       int col,
                       btprnt_region *s);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int btprnt_layout_grid(btprnt_region *r,
                       int nrows,
                       int ncols,
                       int row,
                       int col,
                       btprnt_region *s)
{
    int hspace;
    int vspace;
    int err;

    hspace = r->w / nrows;
    vspace = r->h / ncols;

    err = hspace <= 0 || vspace <= 0;
    err = err || row >= nrows || col >= ncols;

    if (err) {
        s->c = r->c;
        s->x = 0;
        s->y = 0;
        s->w = 0;
        s->h = 0;
        return BTPRNT_NOT_OK;
    }

    s->c = r->c;
    s->x = r->x + hspace * row;
    s->y = r->y + vspace * col;
    s->w = hspace;
    s->h = vspace;

    if (row == (nrows - 1)) s->w = r->w - (hspace * row);
    if (col == (ncols - 1)) s->h = r->h - (vspace * col);

    return BTPRNT_OK;
}
#+END_SRC

Any subregion that is in the last row or column will contain
any "carry-over" that occurs from things not dividing
properly.
* Invert
Inverts colors on a portion of a region.

#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_invert(btprnt_region *r,
                   int xoff, int yoff,
                   int w, int h);
#+END_SRC

Later, add bounds checking.

#+NAME: funcs
#+BEGIN_SRC c
void btprnt_invert(btprnt_region *r,
                   int xoff, int yoff,
                   int w, int h)
{
    int x, y;
    /* TODO: add bounds checking */
    for (x = 0; x < w; x++) {
        for (y = 0; y < h; y ++) {
            int s;
            int xp, yp;
            xp = x + xoff;
            yp = y + yoff;
            s = btprnt_region_read(r, xp, yp);

            if (s) {
                btprnt_region_draw(r, xp, yp, 0);
            } else {
                btprnt_region_draw(r, xp, yp, 1);
            }
        }
    }

}
#+END_SRC
* Bitrow
This copies up to 16 bits of an integer to a row in a
region. The leftmost x, y coordinate is provided, as well
as the pattern, encoded as an unsigned short. The number
of bits is also needed (up to 16).

#+NAME: funcdefs
#+BEGIN_SRC c
void btprnt_bitrow(btprnt_region *reg,
                   int x, int y,
                   int nbits,
                   unsigned short pat);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void btprnt_bitrow(btprnt_region *reg,
                   int x, int y,
                   int nbits,
                   unsigned short pat)
{
    int i;
    if (nbits < 0) return;
    if (nbits > 16) nbits = 16;

    for (i = 0; i < nbits; i++) {
        btprnt_region_draw(reg,
                           x + i, y,
                           (pat & (1 << i)) >> i);
    }
}
#+END_SRC
